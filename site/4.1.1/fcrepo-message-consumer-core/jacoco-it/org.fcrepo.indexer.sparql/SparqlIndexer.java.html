<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>SparqlIndexer.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">fcrepo-message-consumer-core</a> &gt; <a href="index.source.html" class="el_package">org.fcrepo.indexer.sparql</a> &gt; <span class="el_source">SparqlIndexer.java</span></div><h1>SparqlIndexer.java</h1><pre class="source lang-java linenums">/**
 * Copyright 2015 DuraSpace, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.fcrepo.indexer.sparql;

import static com.google.common.util.concurrent.MoreExecutors.listeningDecorator;
import static com.hp.hpl.jena.sparql.util.Context.emptyContext;
import static com.hp.hpl.jena.update.UpdateExecutionFactory.createRemoteForm;
import static java.util.concurrent.Executors.newFixedThreadPool;
import static org.fcrepo.indexer.Indexer.IndexerType.RDF;
import static org.slf4j.LoggerFactory.getLogger;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.net.URI;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Set;
import java.util.concurrent.Callable;

import com.google.common.annotations.VisibleForTesting;
import com.google.common.util.concurrent.ListenableFutureTask;
import com.google.common.util.concurrent.ListeningExecutorService;
import com.hp.hpl.jena.rdf.model.Model;
import com.hp.hpl.jena.rdf.model.StmtIterator;
import com.hp.hpl.jena.graph.Node_URI;
import com.hp.hpl.jena.graph.Triple;
import com.hp.hpl.jena.sparql.engine.http.QueryEngineHTTP;
import com.hp.hpl.jena.sparql.modify.UpdateProcessRemote;
import com.hp.hpl.jena.sparql.modify.request.QuadDataAcc;
import com.hp.hpl.jena.sparql.modify.request.UpdateDataInsert;
import com.hp.hpl.jena.update.UpdateProcessor;
import com.hp.hpl.jena.update.UpdateRequest;

import org.apache.jena.atlas.io.IndentedWriter;
import org.fcrepo.indexer.AsynchIndexer;
import org.slf4j.Logger;


/**
 * Indexes triples from Fedora into a triplestore using SPARQL Update.
 *
 * @author Esm√© Cowles
 * @author ajs6f
 * @since Aug 19, 2013
**/
<span class="fc" id="L60">public class SparqlIndexer extends AsynchIndexer&lt;Model, Void&gt; {</span>

    private String queryBase;
    private String updateBase;
<span class="fc" id="L64">    private boolean formUpdates = false;</span>

<span class="fc" id="L66">    private static final Logger LOGGER = getLogger(SparqlIndexer.class);</span>

    /**
     * Number of threads to use for operating against the triplestore.
     */
<span class="fc" id="L71">    private static final Integer THREAD_POOL_SIZE = 5;</span>

<span class="fc" id="L73">    private ListeningExecutorService executorService =</span>
        listeningDecorator(newFixedThreadPool(THREAD_POOL_SIZE));

    /**
     * Remove any current triples about the Fedora object and replace them with
     * the provided content.
     * {@literal @content RDF in N3 format.}
    **/
    @Override
    public Callable&lt;Void&gt; updateSynch(final URI pid, final Model model) {
<span class="fc" id="L83">        LOGGER.debug(&quot;Received update for: {}&quot;, pid);</span>
<span class="fc" id="L84">        removeSynch(pid, false, true);</span>
        // build a list of triples
<span class="fc" id="L86">        final StmtIterator triples = model.listStatements();</span>
<span class="fc" id="L87">        final QuadDataAcc add = new QuadDataAcc();</span>
<span class="fc bfc" id="L88" title="All 2 branches covered.">        while ( triples.hasNext() ) {</span>
<span class="fc" id="L89">            add.addTriple( triples.nextStatement().asTriple() );</span>
        }

        // send update to server
<span class="fc" id="L93">        LOGGER.debug(&quot;Sending update request for pid: {}&quot;, pid);</span>
<span class="fc" id="L94">        return exec(new UpdateRequest(new UpdateDataInsert(add)));</span>
    }

    /**
     * Perform a DESCRIBE query for triples about the Fedora object and remove
     * all triples with subjects starting with the same subject.
    **/
    @Override
    public Callable&lt;Void&gt; removeSynch(final URI subject) {
<span class="fc" id="L103">        return removeSynch(subject, true, false);</span>
    }

    @VisibleForTesting
    protected Callable&lt;Void&gt; removeSynch(final URI subject, final boolean recursive, final boolean blocking) {

<span class="fc" id="L109">        LOGGER.debug(&quot;Received remove for: {}&quot;, subject);</span>
        // find triples/quads to delete
<span class="fc" id="L111">        final String describeQuery = &quot;DESCRIBE &lt;&quot; + subject.toString() + &quot;&gt;&quot;;</span>
<span class="fc" id="L112">        final QueryEngineHTTP qexec = buildQueryEngineHTTP(describeQuery);</span>
<span class="fc" id="L113">        final Iterator&lt;Triple&gt; results = qexec.execDescribeTriples();</span>

        // build list of triples to delete
<span class="fc" id="L116">        final Set&lt;String&gt; uris = new HashSet&lt;&gt;();</span>
<span class="fc bfc" id="L117" title="All 2 branches covered.">        while ( results.hasNext() ) {</span>
<span class="fc" id="L118">            final Triple triple = results.next();</span>

            // add subject uri, if it is part of this object
<span class="pc bpc" id="L121" title="1 of 2 branches missed.">            if ( triple.getSubject().isURI() ) {</span>
<span class="fc" id="L122">                final String uri = ((Node_URI)triple.getSubject()).getURI();</span>
<span class="pc bpc" id="L123" title="1 of 2 branches missed.">                if ( matches(subject, uri) ) {</span>
<span class="fc" id="L124">                    uris.add(uri);</span>
                }
            }

<span class="fc bfc" id="L128" title="All 2 branches covered.">            if ( recursive ) {</span>
                // add object uri, if it is part of this object
<span class="fc bfc" id="L130" title="All 2 branches covered.">                if ( triple.getObject().isURI() ) {</span>
<span class="fc" id="L131">                    final String uri = ((Node_URI)triple.getObject()).getURI();</span>
<span class="fc bfc" id="L132" title="All 2 branches covered.">                    if ( matches(subject, uri) ) {</span>
<span class="fc" id="L133">                        uris.add(uri);</span>
                    }
                }
            }
<span class="fc" id="L137">        }</span>
<span class="fc" id="L138">        qexec.close();</span>

        // build update commands
<span class="fc" id="L141">        final UpdateRequest del = buildUpdateRequest();</span>
<span class="fc bfc" id="L142" title="All 2 branches covered.">        for (final String uri : uris) {</span>
<span class="fc" id="L143">            final String cmd = &quot;DELETE WHERE { &lt;&quot; + uri + &quot;&gt; ?p ?o }&quot;;</span>
<span class="fc" id="L144">            LOGGER.debug(&quot;Executing: {}&quot;, cmd);</span>
<span class="fc" id="L145">            del.add(cmd);</span>
<span class="fc" id="L146">        }</span>

        // send updates
<span class="fc" id="L149">        return exec(del, blocking);</span>
    }

    /**
     * Determine whether arg candidate is a sub-URI of arg resource, defined as candidate-URI starting
     * with resource-URI, plus an option suffix starting with a hash (#) or slash (/)
     * suffix.
    **/
    private boolean matches( final URI resource, final String candidate) {
        // All triples that will match this logic are ones that:
        // - have a candidate subject or object that equals the target resource of removal, or
        // - have a candidate subject or object that is prefixed with the resource of removal
        //    (therefore catching all children).
<span class="pc bpc" id="L162" title="1 of 6 branches missed.">        return resource.toString().equals(candidate) || candidate.startsWith(resource.toString() + &quot;/&quot;)</span>
            || candidate.startsWith(resource.toString() + &quot;#&quot;);
    }

    private Callable&lt;Void&gt; exec(final UpdateRequest update) {
<span class="fc" id="L167">        return exec(update, false);</span>
    }

    private Callable&lt;Void&gt; exec(final UpdateRequest update, final boolean blocking) {
<span class="fc bfc" id="L171" title="All 2 branches covered.">        if (update.getOperations().isEmpty()) {</span>
<span class="fc" id="L172">            LOGGER.debug(&quot;Received empty update/remove operation.&quot;);</span>
<span class="fc" id="L173">            return new Callable&lt;Void&gt;() {</span>

                @Override
                public Void call() {
<span class="fc" id="L177">                    return null;</span>
                }
            };
        }

<span class="fc" id="L182">        final Callable&lt;Void&gt; callable = new Callable&lt;Void&gt;() {</span>

            @Override
            public Void call() {

<span class="pc bpc" id="L187" title="1 of 2 branches missed.">                if (formUpdates) {</span>
                    // form updates
<span class="nc" id="L189">                    final UpdateProcessor proc =</span>
                        createRemoteForm(update, updateBase);
<span class="nc" id="L191">                    proc.execute();</span>
<span class="nc" id="L192">                } else {</span>
                    // normal SPARQL updates
<span class="fc" id="L194">                    final UpdateProcessRemote proc =</span>
                        new UpdateProcessRemote(update, updateBase,
                                emptyContext);
                    try {
<span class="fc" id="L198">                        proc.execute();</span>
<span class="nc" id="L199">                    } catch (final Exception e) {</span>
<span class="nc" id="L200">                        LOGGER.error(</span>
                                &quot;Error executing Sparql update/remove!&quot;, e);
<span class="fc" id="L202">                    }</span>
                }
<span class="fc" id="L204">                return null;</span>
            }
        };

<span class="fc bfc" id="L208" title="All 2 branches covered.">        if (blocking) {</span>
            try {
<span class="fc" id="L210">                callable.call();</span>
<span class="nc" id="L211">            } catch (Exception e) {</span>
<span class="nc" id="L212">                LOGGER.error(&quot;Error calling Sparql update/remove!, {}&quot;, e.getMessage());</span>
<span class="pc" id="L213">            }</span>

        } else {
<span class="fc" id="L216">            final ListenableFutureTask&lt;Void&gt; task =</span>
                ListenableFutureTask.create(callable);
<span class="fc" id="L218">            task.addListener(new Runnable() {</span>

                @Override
                public void run() {
<span class="fc" id="L222">                    LOGGER.debug(&quot;Completed Sparql update/removal.&quot;);</span>
<span class="pc bpc" id="L223" title="1 of 2 branches missed.">                    if (LOGGER.isTraceEnabled()) {</span>
<span class="nc" id="L224">                        try (</span>
<span class="nc" id="L225">                            final OutputStream buffer = new ByteArrayOutputStream()) {</span>
<span class="nc" id="L226">                            final IndentedWriter out = new IndentedWriter(buffer);</span>
<span class="nc" id="L227">                            update.output(out);</span>
<span class="nc" id="L228">                            LOGGER.trace(&quot;Executed update/remove operation:\n{}&quot;,</span>
                                    buffer.toString());
<span class="nc" id="L230">                            out.close();</span>
<span class="nc bnc" id="L231" title="All 8 branches missed.">                        } catch (final IOException e) {</span>
<span class="nc" id="L232">                            LOGGER.error(</span>
                                    &quot;Couldn't retrieve execution of update/remove operation!&quot;,
                                    e);
<span class="nc" id="L235">                        }</span>
                    }
<span class="fc" id="L237">                }</span>
            }, executorService);
<span class="fc" id="L239">            executorService.submit(task);</span>
        }

<span class="fc" id="L242">        return callable;</span>
    }

    @Override
    public IndexerType getIndexerType() {
<span class="fc" id="L247">        return RDF;</span>
    }

    /**
     * Set whether to use SPARQL Update or form updates.
     * @param b boolean value for whether to use SPARQL update or form update
    **/
    public void setFormUpdates( final boolean b ) {
<span class="fc" id="L255">        this.formUpdates = b;</span>
<span class="fc" id="L256">    }</span>

    /**
     * Set base URL for SPARQL Query requests.
     * @param url base URL for SPARQL query request
    **/
    public void setQueryBase( final String url ) {
<span class="fc" id="L263">        this.queryBase = url;</span>
<span class="fc" id="L264">    }</span>

    /**
     * Set base URL for SPARQL Update requests.
     * @param url base URL for SPARQL update requests
    **/
    public void setUpdateBase( final String url ) {
<span class="fc" id="L271">        this.updateBase = url;</span>
<span class="fc" id="L272">    }</span>

    @Override
    public ListeningExecutorService executorService() {
<span class="fc" id="L276">        return executorService;</span>
    }

    /**
     * Note: Protected for Unit Tests to overwrite.
     * @param describeQuery the describe query
     * @return the query engine http
     */
    protected QueryEngineHTTP buildQueryEngineHTTP(final String describeQuery) {
<span class="fc" id="L285">        return new QueryEngineHTTP( queryBase, describeQuery );</span>
    }

    /**
     * Note: Protected for Unit Tests to overwrite.
     * @return update request
     */
    protected UpdateRequest buildUpdateRequest() {
<span class="fc" id="L293">        return new UpdateRequest();</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.2.201409121644</span></div></body></html>